"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.who = exports.execute = exports.build = exports.compile = void 0;
const path = __importStar(require("path"));
const cli_nix_1 = __importDefault(require("./cli-nix"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const DockerCompiler_1 = __importDefault(require("./DockerCompiler"));
const CachingUrlFetcher_1 = __importDefault(require("./CachingUrlFetcher"));
const errors_1 = require("./errors");
const logga = __importStar(require("@stencila/logga"));
const compiler = new DockerCompiler_1.default(new CachingUrlFetcher_1.default());
const logger = logga.getLogger('dockta');
/**
 * Log an error to logga
 *
 * @param error
 */
function loggingErrorHandler(error) {
    if (error instanceof errors_1.ApplicationError) {
        logger.error(error.message);
    }
    else {
        logger.error(error);
    }
}
/**
 * Convert an object to a string (maybe to go to stdout or back over HTTP)
 *
 * @param object The object to print
 * @param format The format use: `json` or `yaml`
 */
function stringifyNode(object, format) {
    if (!object) {
        return '';
    }
    return format === 'yaml'
        ? js_yaml_1.default.safeDump(object, { lineWidth: 120 })
        : JSON.stringify(object, null, '  ');
}
/**
 * Compile a folder to an environment, optionally with nix too.
 *
 * @param folder Path of the folder to compile
 * @param useNix Compile the environment for nix
 */
async function compile(folder, useNix, addStencila, from) {
    const absoluteFolder = path.resolve(folder);
    const comments = true;
    const build = false;
    const environ = await compiler
        .compile('file://' + absoluteFolder, build, comments, addStencila, from)
        .catch(loggingErrorHandler);
    if (useNix) {
        cli_nix_1.default.compile(environ, folder);
    }
}
exports.compile = compile;
/**
 * Build an environment from a folder, optionally using nix.
 *
 * @param folder Path of the folder to build
 * @param useNix Build the environment with nix
 */
async function build(folder, useNix, addStencila, from) {
    const absoluteFolder = path.resolve(folder);
    if (useNix) {
        await cli_nix_1.default.build(absoluteFolder);
    }
    else {
        const comments = true;
        const build = true;
        compiler
            .compile(absoluteFolder, build, comments, addStencila, from)
            .catch(loggingErrorHandler);
    }
}
exports.build = build;
/**
 * Execute a command inside a folder, by first building the environment inside that folder.
 * If the environment has already been built it will not be rebuilt.
 *
 * @param folder Path of folder to build into environment
 * @param command The command to execute
 * @param useNix Build the environment with nix
 * @param outputFormat The format to output as ('json' or 'yaml')
 * @param outputFunction Optional callback to receive the output. If undefined, node output goes to stdout.
 */
async function execute(folder, command, useNix, outputFormat = 'json', outputFunction = console.log) {
    const absoluteFolder = path.resolve(folder);
    if (useNix) {
        await cli_nix_1.default.execute(absoluteFolder, command);
    }
    else {
        const node = await compiler
            .execute('file://' + absoluteFolder, command)
            .catch(loggingErrorHandler);
        const nodeString = stringifyNode(node, outputFormat);
        outputFunction(nodeString);
    }
}
exports.execute = execute;
/**
 * List the people your project depends upon.
 *
 * @param folder Path of folder to examine
 * @param depth Maximum depth of dependencies to traverse to find people
 * @param outputFunction Optional callback to receive the output. If undefined, utput goes to stdout.
 */
async function who(folder, depth = 100, outputFunction = console.log) {
    const absoluteFolder = path.resolve(folder);
    const people = await compiler
        .who('file://' + absoluteFolder, depth)
        .catch(loggingErrorHandler);
    if (!people) {
        outputFunction('Nobody (?)');
    }
    else {
        // Sort by number of packages descending and then alphabetically ascending
        const sorted = Object.entries(people).sort(([aName, aPkgs], [bName, bPkgs]) => {
            if (aPkgs.length > bPkgs.length)
                return -1;
            if (aPkgs.length < bPkgs.length)
                return 1;
            if (aName < bName)
                return -1;
            if (aName > bName)
                return 1;
            return 0;
        });
        // Output in a CLI friendly way
        const output = sorted
            .map(([name, packages]) => {
            return `${name} (${packages.join(', ')})`;
        })
            .join(', ');
        outputFunction(output);
    }
}
exports.who = who;
