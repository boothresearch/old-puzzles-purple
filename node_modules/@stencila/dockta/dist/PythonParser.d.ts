import { SoftwarePackage } from '@stencila/schema';
import Parser from './Parser';
export declare enum RequirementType {
    Named = 0,
    URL = 1
}
interface PythonRequirement {
    /**
     * Type of requirement specified (name or URL)
     */
    type: RequirementType;
    /**
     * Name or URL value of the requirement
     */
    value: string;
    /**
     * Version of the requirement
     */
    version?: string | null;
}
/**
 * Parser to be used on a directory with Python source code and (optionally) a `requirements.txt` file.
 * If no `requirements.txt` file exists then the Parser will attempt to read requirements from the Python source code.
 */
export default class PythonParser extends Parser {
    parse(): Promise<SoftwarePackage | null>;
    /**
     * Convert a `PythonRequirement` into a `SoftwarePackage` by augmenting with metadata from PyPI
     */
    private createPackage;
    /**
     * Parse a `requirements.txt` file at `path` and return a list of `PythonRequirement`s
     */
    parseRequirementsFile(path: string): Promise<Array<PythonRequirement>>;
    /**
     * Parse Python source files are find any non-system imports, return this as an array of `PythonRequirement`s.
     */
    generateRequirementsFromSource(): Array<PythonRequirement>;
    /**
     * Parse Python source files are find all imports (including system imports).
     */
    findImports(): Array<string>;
    /**
     * Parse Python a single Python source file for imports.
     */
    readImportsInFile(path: string): Array<string>;
}
export {};
