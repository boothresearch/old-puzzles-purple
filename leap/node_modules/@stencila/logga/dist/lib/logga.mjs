function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/* global CustomEvent */
const LOG_EVENT_NAME = 'stencila:logga';
/**
 * The global log event bus from which all events are emitted
 * and handlers are attached.
 *
 * When in Node, exposes the event API of Node `process`.
 * When in a browser, creates adaptor functions to mimic the
 * Node API using `window` event handling functions.
 */

let bus;

if (typeof process !== 'undefined') {
  bus = {
    /* eslint-disable @typescript-eslint/unbound-method */
    emit: process.emit,
    listeners: process.listeners,
    addListener: process.addListener,
    removeListener: process.removeListener,
    removeAllListeners: process.removeAllListeners
  };
}
/* istanbul ignore next */


if (typeof window !== 'undefined') {
  const listeners = new Map();
  bus = {
    emit: (event, data) => {
      window.dispatchEvent(new CustomEvent(event, {
        detail: data
      }));
    },
    listeners: () => {
      return Array.from(listeners.keys());
    },
    addListener: (event, handler) => {
      const listener = customEvent => handler(customEvent.detail); // @ts-ignore


      window.addEventListener(event, listener);
      listeners.set(handler, listener);
    },
    removeListener: (event, handler) => {
      const listener = listeners.get(handler);
      if (listener === undefined) return; // @ts-ignore

      window.removeEventListener(event, listener);
      listeners.delete(handler);
    },
    removeAllListeners: event => {
      Array.from(listeners.values()).map(listener => {
        // @ts-ignore
        window.removeEventListener(event, listener);
      });
      listeners.clear();
    }
  };
}
/**
 * The severity level of a log event.
 */


var LogLevel;

(function (LogLevel) {
  LogLevel[LogLevel["error"] = 0] = "error";
  LogLevel[LogLevel["warn"] = 1] = "warn";
  LogLevel[LogLevel["info"] = 2] = "info";
  LogLevel[LogLevel["debug"] = 3] = "debug";
})(LogLevel || (LogLevel = {}));
/**
 * Take a message `string`, or `LogInfo` object,
 * and emit an event with a `LogData` object.
 *
 * For `LogLevel.error`, if `LogInfo` does not have a `stack`,
 * one is generated and set on the `LogData`.
 *
 * @param info
 * @param level
 */


function emitLogData(info, tag, level) {
  let message = '';

  if (typeof info === 'object' && info.message !== undefined) {
    message = info.message;
  } else if (typeof info === 'string') {
    message = info;
  }

  const data = {
    tag,
    level,
    message
  };

  if (typeof info === 'object' && info.stack !== undefined) {
    data.stack = info.stack;
  } else if (level <= LogLevel.error) {
    const error = new Error();

    if (error.stack !== undefined) {
      // Remove the first three lines of the stack trace which
      // are not useful (see issue #3)
      const lines = error.stack.split('\n');
      data.stack = [lines[0], ...lines.slice(3)].join('\n');
    }
  }

  bus.emit(LOG_EVENT_NAME, data);
}
/**
 * Get all handlers.
 */


function handlers() {
  return bus.listeners(LOG_EVENT_NAME);
}
/**
 * Add a handler.
 *
 * @param handler A function that handles the log data.
 * @param filter Options for filtering log data prior to sending to the handler.
 * @param filter.tags A list of tags that the log data should match.
 * @param filter.maxLevel The maximum log level.
 * @param filter.messageRegex A regex that the log message should match.
 * @param filter.func A function that determines if handler is called
 * @returns The handler function that was added.
 */

function addHandler(handler, filter = {}) {
  let listener = handler;
  const {
    tags,
    maxLevel,
    messageRegex,
    func
  } = filter;

  if (tags !== undefined || maxLevel !== undefined || messageRegex !== undefined || func !== undefined) {
    listener = logData => {
      if (tags !== undefined && !tags.includes(logData.tag)) return;
      if (maxLevel !== undefined && logData.level > maxLevel) return;
      if (messageRegex !== undefined && !messageRegex.test(logData.message)) return;
      if (func !== undefined && !func(logData)) return;
      handler(logData);
    };
  }

  bus.addListener(LOG_EVENT_NAME, listener);
  return listener;
}
/**
 * Remove a handler.
 *
 * @param handler The handler function to remove.
 */

function removeHandler(handler) {
  bus.removeListener(LOG_EVENT_NAME, handler);
}
/**
 * Remove all handlers.
 */

function removeHandlers() {
  bus.removeAllListeners(LOG_EVENT_NAME);
}
/**
 * Replace all existing handlers with a new handler.
 *
 * This is a convenience function that can be used to
 * replace the default handler with a new one which logs
 * to the console.
 */

function replaceHandlers(handler) {
  removeHandlers();
  addHandler(handler);
}
const defaultHandlerHistory = new Map();
/**
 * Default log event handler.
 *
 * Prints the event data to stderr:
 *
 * - with cutesy emoji, colours and stack (for errors) if stderr is TTY (for human consumption)
 * - as JSON if stderr is not TTY (for machine consumption e.g. log files)
 *
 * If in Node.js, and the
 *
 * @param data The log data to handle
 * @param options.maxLevel The maximum log level to print. Defaults to `info`.
 * @param options.showStack Whether or not to show any stack traces for errors. Defaults to `false`.
 * @param options.exitOnError Whether or not to exit the process on the first error. Defaults to `true`.
 * @param options.throttle.signature The log event signature to use for throttling. Defaults to '' (i.e. all events)
 * @param options.throttle.duration The duration for throttling (milliseconds). Defaults to 1000ms
 */

function defaultHandler(data, options = {}) {
  const {
    tag,
    level,
    message,
    stack
  } = data; // Skip if greater than desired reporting level

  const {
    maxLevel = LogLevel.info
  } = options;
  if (level > maxLevel) return; // Skip if within throttling duration for the event signature

  const {
    throttle
  } = options;

  if (throttle !== undefined) {
    const signature = throttle.signature !== undefined ? throttle.signature : '';
    const eventSignature = signature.replace(/\${tag}/, tag).replace(/\${level}/, level.toString()).replace(/\${message}/, message);
    const lastTime = defaultHandlerHistory.get(eventSignature);

    if (lastTime !== undefined) {
      const duration = throttle.duration !== undefined ? throttle.duration : 1000;
      if (Date.now() - lastTime < duration) return;
    }

    defaultHandlerHistory.set(eventSignature, Date.now());
  } // Generate a human readable or machine readable log entry based on
  // environment


  let entry = '';

  if (typeof process !== 'undefined' && process.stderr !== undefined && process.stderr.isTTY !== true) {
    entry = JSON.stringify(_extends({
      time: new Date().toISOString()
    }, data));
  } else {
    const index = level < 0 ? 0 : level > 3 ? 3 : level;
    const label = LogLevel[index].toUpperCase().padEnd(5, ' ');
    /* istanbul ignore next */

    if (typeof window !== 'undefined') {
      entry = `${label} ${tag} ${message}`;
    } else {
      const emoji = ['üö®', '‚ö†', 'üõà', 'üêõ'][index];
      const colour = ['\u001b[31;1m', '\u001b[33;1m', '\u001b[34;1m', '\u001b[30;1m'][index];
      const cyan = '\u001b[36m';
      const reset = '\u001b[0m';
      entry = `${emoji} ${colour}${label}${reset} ${cyan}${tag}${reset} ${message}`;
    }

    const {
      showStack = false
    } = options;
    if (showStack && stack !== undefined) entry += '\n  ' + stack;
  }

  console.error(entry);
  const {
    exitOnError = true
  } = options;

  if (typeof process !== 'undefined' && exitOnError && level === LogLevel.error) {
    process.exit(1);
  }
} // Enable the default handler if there no other handler
// already enabled e.g. by another package using `logga`

if (handlers().length === 0) addHandler(defaultHandler);
/**
 * Get a logger for the specific application or package.
 *
 * Each of the returned logger functions are the public interface for
 * posting log messages.
 *
 * @param tag The unique application or package name
 */
// eslint-disable-next-line @typescript-eslint/explicit-function-return-type

function getLogger(tag) {
  return {
    error(message) {
      emitLogData(message, tag, LogLevel.error);
    },

    warn(message) {
      emitLogData(message, tag, LogLevel.warn);
    },

    info(message) {
      emitLogData(message, tag, LogLevel.info);
    },

    debug(message) {
      emitLogData(message, tag, LogLevel.debug);
    }

  };
}

export { LogLevel, addHandler, defaultHandler, getLogger, handlers, removeHandler, removeHandlers, replaceHandlers };
//# sourceMappingURL=logga.mjs.map
