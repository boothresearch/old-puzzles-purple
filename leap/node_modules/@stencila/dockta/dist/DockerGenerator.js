"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Generator_1 = __importDefault(require("./Generator"));
const generators_1 = __importDefault(require("./generators"));
const PREFERRED_UBUNTU_VERSION = '19.10';
/**
 * Compare semantic version numbers
 *
 * @param versionOne
 * @param versionTwo
 */
function versionCompare(versionOne, versionTwo) {
    if (versionOne === versionTwo) {
        return 0; // shortcut
    }
    const splitV1 = versionOne.split('.');
    const splitV2 = versionTwo.split('.');
    while (splitV1.length < splitV2.length) {
        splitV1.push('0');
    }
    while (splitV2.length < splitV1.length) {
        splitV2.push('0');
    }
    for (let i = 0; i < splitV1.length; ++i) {
        const component1 = parseInt(splitV1[i], 10);
        const component2 = parseInt(splitV2[i], 10);
        if (component1 < component2) {
            return -1;
        }
        else if (component1 > component2) {
            return 1;
        }
    }
    return 0; // all components equal
}
/**
 * A Dockerfile generator that collects instructions from
 * all the other generators to allow for images that support
 * multiple languages.
 */
class DockerGenerator extends Generator_1.default {
    constructor(urlFetcher, environ, folder, baseImage) {
        super(urlFetcher, folder, baseImage);
        this.environ = environ;
        // Each of the environment's `softwareRequirements` is
        // matched to one of the language specific generators
        // (the first that says that it `applies`)
        this.generators = [];
        for (const pkg of this.environ.softwareRequirements) {
            for (const GeneratorClass of generators_1.default) {
                // @ts-ignore
                const generator = new GeneratorClass(urlFetcher, pkg, folder);
                if (generator.applies()) {
                    this.generators.push(generator);
                    break;
                }
            }
        }
    }
    /**
     * Collect arrays of string from each child generator
     * and flatten them into an array of strings.
     * Used below for method overrides.
     *
     * @param func The child generator method to call
     */
    collect(func) {
        // @ts-ignore
        return (this.generators
            .map(func)
            // @ts-ignore
            .reduce((memo, items) => memo.concat(items), []));
    }
    /**
     * Join strings from each child generator
     *
     * @param func The child generator method to call
     */
    join(func, sep = ' \\\n && ') {
        // @ts-ignore
        return this.generators
            .map(func)
            .filter((cmd) => cmd)
            .join(sep);
    }
    // Methods that override those in `Generator`
    applies() {
        return true;
    }
    baseVersion() {
        return [PREFERRED_UBUNTU_VERSION]
            .concat(this.generators
            .filter((generator) => generator.baseName() === this.baseName()) // filter to generators with matching base name
            .map((generator) => generator.baseVersion()))
            .sort(versionCompare)[0];
    }
    envVars(sysVersion) {
        return this.collect((generator) => generator.envVars(sysVersion));
    }
    aptKeysCommand(sysVersion) {
        return this.join((generator) => generator.aptKeysCommand(sysVersion));
    }
    aptRepos(sysVersion) {
        return this.collect((generator) => generator.aptRepos(sysVersion));
    }
    aptPackages(sysVersion) {
        // Get the set of unique apt packages requested by each child generator
        const pkgs = this.collect((generator) => generator.aptPackages(sysVersion)).sort();
        return Array.from(new Set(pkgs));
    }
    stencilaInstall(sysVersion) {
        return this.join((generator) => generator.stencilaInstall(sysVersion));
    }
    installFiles(sysVersion) {
        return this.collect((generator) => generator.installFiles(sysVersion));
    }
    installCommand(sysVersion) {
        return this.join((generator) => generator.installCommand(sysVersion));
    }
    projectFiles(sysVersion) {
        return this.collect((generator) => generator.projectFiles(sysVersion));
    }
    runCommand(sysVersion) {
        return this.join((generator) => generator.runCommand(sysVersion));
    }
}
exports.default = DockerGenerator;
