"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const schema_1 = require("@stencila/schema");
const DockerParser_1 = __importDefault(require("./DockerParser"));
const parsers_1 = __importDefault(require("./parsers"));
const DockerGenerator_1 = __importDefault(require("./DockerGenerator"));
const DockerBuilder_1 = __importDefault(require("./DockerBuilder"));
const DockerExecutor_1 = __importDefault(require("./DockerExecutor"));
/**
 * Compiles a project into a Dockerfile, or Docker image
 */
class DockerCompiler {
    constructor(urlFetcher) {
        this.urlFetcher = urlFetcher;
    }
    /**
     * Compile a project
     *
     * @param source The folder, Dockerfile or `SoftwareEnvironment` to compile
     * @param build Should the Docker image be built?
     * @param comments Should comments be added to the Dockerfile?
     * @param stencila Should relevant Stencila language packages be installed in the image?
     * @param baseImage override the FROM parameter of the Dockerfile
     */
    async compile(source, build = true, comments = true, stencila = false, baseImage) {
        var _a;
        let folder;
        if (source.startsWith('file://')) {
            folder = source.substring(7);
        }
        else {
            folder = source;
        }
        let dockerfile;
        let environ;
        if (fs_1.default.existsSync(path_1.default.join(folder, 'Dockerfile'))) {
            // Dockerfile found so use that
            dockerfile = 'Dockerfile';
            environ = await new DockerParser_1.default(this.urlFetcher, folder).parse();
        }
        else {
            if (fs_1.default.existsSync(path_1.default.join(folder, 'environ.jsonld'))) {
                // Read existing environment from file
                const jsonld = fs_1.default.readFileSync(path_1.default.join(folder, 'environ.jsonld'), 'utf8');
                const initializer = JSON.parse(jsonld);
                environ = new schema_1.SoftwareEnvironment(initializer);
            }
            else {
                // Create environment by merging packages
                // generated by each language parser
                environ = new schema_1.SoftwareEnvironment();
                environ.name = path_1.default.basename(folder);
                for (const ParserClass of parsers_1.default) {
                    const parser = new ParserClass(this.urlFetcher, folder);
                    const pkg = await parser.parse();
                    if (pkg)
                        environ.softwareRequirements.push(pkg);
                }
                // Save environ as an intermediate file
                const jsonld = JSON.stringify(environ.toJSONLD(), null, '  ');
                fs_1.default.writeFileSync(path_1.default.join(folder, '.environ.jsonld'), jsonld);
            }
            // Generate Dockerfile
            dockerfile = '.Dockerfile';
            new DockerGenerator_1.default(this.urlFetcher, environ, folder, baseImage).generate(comments, stencila);
        }
        if (build) {
            // Use the name of the environment, if possible
            const name = (_a = environ === null || environ === void 0 ? void 0 : environ.name) !== null && _a !== void 0 ? _a : undefined;
            // Build the image!
            const builder = new DockerBuilder_1.default();
            await builder.build(folder, name, dockerfile);
        }
        return environ;
    }
    /**
     * Execute the project by compiling, building and running a Docker container for it
     *
     * @param source The project to execute
     */
    async execute(source, command = '') {
        let folder;
        if (source.startsWith('file://')) {
            folder = source.substring(7);
        }
        else {
            folder = source;
        }
        // Compile the environment first
        const environ = await this.compile(source);
        if (!environ)
            throw new Error('Environment not created');
        if (!environ.name)
            throw new Error('Environment does not have a name');
        // Execute the environment's image (which is built in compile())
        const executor = new DockerExecutor_1.default();
        return executor.execute(environ.name, folder, command);
    }
    /**
     * Find out who contributed to the packages that your project
     * depends upon.
     *
     * @param folder The project to examine
     * @param maxDepth The maximum dependency recursion depth
     */
    async who(folder, maxDepth = 100) {
        const environ = await this.compile(folder, false);
        if (!environ)
            throw new Error('Environment not created');
        const people = {};
        /**
         * Get the people for a software package
         *
         * @param pkg The package
         * @param depth The current recursion depth
         */
        function get(pkg, depth = 0) {
            const all = pkg.authors.concat(pkg.contributors).concat(pkg.creators);
            for (const person of all) {
                const name = person.name;
                if (people[name]) {
                    if (!people[name].includes(pkg.name))
                        people[name].push(pkg.name);
                }
                else {
                    people[name] = [pkg.name];
                }
            }
            // Keep going deeper, if we haven't yet reached the maximum depth
            if (depth < maxDepth) {
                for (const req of pkg.softwareRequirements) {
                    get(req, depth + 1);
                }
            }
        }
        get(environ);
        return people;
    }
}
exports.default = DockerCompiler;
