"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.REQUEST_CACHE_DIR = void 0;
const errors_1 = require("./errors");
const node_persist_1 = __importDefault(require("node-persist"));
const got_1 = __importDefault(require("got"));
exports.REQUEST_CACHE_DIR = '/tmp/dockta-request-cache';
let REQUEST_CACHE_INITIALISED = false;
/**
 * The default URL fetcher that Dockta uses. Fetches using `got` and caches results using `persist`
 */
class CachingUrlFetcher {
    /**
     * Fetch a URL using `got`, attempting to retrieve it from cache first.
     */
    async fetchUrl(url, options = { json: true }) {
        let value = await CachingUrlFetcher.getFromCache(url);
        if (value)
            return value;
        try {
            const response = await got_1.default(url, options);
            value = response.body;
        }
        catch (error) {
            if (error.statusCode === 404) {
                value = null;
            }
            else if ([
                'ENOTFOUND',
                'ECONNRESET',
                'EAI_AGAIN',
                'DEPTH_ZERO_SELF_SIGNED_CERT',
            ].includes(error.code)) {
                // These are usually connection errors
                throw new errors_1.NetworkError(`There was a problem fetching ${url} (${error.code}). Are you connected to the internet?`);
            }
            else {
                throw error;
            }
        }
        await CachingUrlFetcher.setToCache(url, value);
        return value;
    }
    /**
     *  Try to get a result from the `persist` cache. This method with initialise the `persist` cache if it has not been
     *  set up.
     */
    static async getFromCache(url) {
        if (!REQUEST_CACHE_INITIALISED) {
            await node_persist_1.default.init({
                dir: exports.REQUEST_CACHE_DIR,
                ttl: 60 * 60 * 1000,
            });
            REQUEST_CACHE_INITIALISED = true;
        }
        try {
            return await node_persist_1.default.getItem(url);
        }
        catch (error) {
            if (error.message.includes('does not look like a valid storage file')) {
                // It seems that `persist.setItem` is not atomic and that the storage file can
                // have zero bytes when we make multiple requests, some of which are for the same
                // url. So we ignore this error and continue with the duplicate request.
                return null;
            }
            else {
                throw error;
            }
        }
    }
    /**
     * Set a value (URL response body, usually) to the `persist` cache.
     */
    static async setToCache(url, value) {
        await node_persist_1.default.setItem(url, value);
    }
}
exports.default = CachingUrlFetcher;
